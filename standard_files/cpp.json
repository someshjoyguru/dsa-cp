{
    // Boilerplate snippet
    "boilerplate": {
        "prefix": "ctemp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);",
            "#define f(i,a,b) for (ll (i)=(a); (i)<(b); (i)++)",
            "#define vll vector<ll>",
            "#define in(n) ll n; cin>>n;",
            "#define sin(s) string (s); cin>>(s);",
            "#define vin(v,n) vll (v)(n); f(i,0,n)cin>>(v)[i];",
            "#define all(v) (v).begin(),(v).end()",
            "#define sort(v) sort(all(v));",
            "#define pYES cout<<\"YES\"<<endl;",
            "#define pNO cout<<\"NO\"<<endl;",
            "",
            "void solve(){",
            "\t$1",
            "}",
            "",
            "int main(){",
            "\tfast;",
            "\tint t=1;",
            "\tcin >> t;",
            "\twhile(t--)solve();",
            "}"
        ],
        "description": "Standard Competitive Programming Template"
    },
    "Competitive Template": {
        "prefix": "boilerplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "#define fast ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);cerr.rdbuf(cout.rdbuf());",
            "#define f(i,a,b) for (ll (i)=(a); (i)<(b); (i)++)",
            "#define rf(i,a,b) for (ll (i)=(a); (i)>=(b); (i)--)",
            "#define vll vector<ll>",
            "#define vvll vector<vll>",
            "#define in(n) ll n; cin>>n;",
            "#define sin(s) string (s); cin>>(s);",
            "#define vin(v,n) vll (v)(n); f(i,0,n)cin>>(v)[i];",
            "#define all(v) (v).begin(),(v).end()",
            "#define rall(v) (v).rbegin(),(v).rend()",
            "#define sort(v) sort(all(v));",
            "#define rsort(v) sort(v) reverse(all(v));",
            "#define pYES cout<<\"YES\\n\";",
            "#define pNO cout<<\"NO\\n\";",
            "const ll mod = 1000000007;",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define debug(x) cerr << #x << \" = \"; _print(x); cerr << endl;",
            "#else",
            "#define debug(x)",
            "#endif",
            "",
            "template <typename T>",
            "void _print(T x) { cerr << x; }",
            "template <typename T, typename V>",
            "void _print(pair<T, V> p) { cerr << \"{\"; _print(p.first); cerr << \", \"; _print(p.second); cerr << \"}\"; }",
            "template <typename T>",
            "void _print(vector<T> v) { cerr << \"[ \"; for (T i : v) { _print(i); cerr << \" \"; } cerr << \"]\"; }",
            "template <typename T>",
            "void _print(set<T> s) { cerr << \"{ \"; for (T i : s) { _print(i); cerr << \" \"; } cerr << \"}\"; }",
            "template <typename T, typename V>",
            "void _print(map<T, V> m) { cerr << \"{ \"; for (auto i : m) { _print(i); cerr << \" \"; } cerr << \"}\"; }",
            "/* *********************Template ends here************** */",
            "",
            "",
            "void solve() {",
            "    $1",
            "}",
            "",
            "int main() {",
            "    fast;",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t--) solve();",
            "}"
        ],
        "description": "Competitive Programming Template"
    },


    // Modular Arithmetic
    "modulus": {
        "prefix": "modulus",
        "body": [
            "// Mod Template",
            "template <typename T>",
            "constexpr T power(T a, ll b, T res = 1) {",
            "    for (; b != 0; b /= 2, a *= a) {",
            "        if (b & 1) {",
            "            res *= a;",
            "        }",
            "    }",
            "    return res;",
            "}",
            "",
            "template <typename T>",
            "constexpr T safeMod(T x, T m) {",
            "    x %= m;",
            "    if (x < 0) {",
            "        x += m;",
            "    }",
            "    return x;",
            "}",
            "",
            "template <typename T>",
            "constexpr std::pair<T, T> invGcd(T a, T b) {",
            "    a = safeMod(a, b);",
            "    if (a == 0) {",
            "        return {b, 0};",
            "    }",
            "",
            "    T s = b, t = a;",
            "    T m0 = 0, m1 = 1;",
            "",
            "    while (t) {",
            "        T u = s / t;",
            "        s -= t * u;",
            "        m0 -= m1 * u;",
            "",
            "        std::swap(s, t);",
            "        std::swap(m0, m1);",
            "    }",
            "",
            "    if (m0 < 0) {",
            "        m0 += b / s;",
            "    }",
            "",
            "    return {s, m0};",
            "}",
            "",
            "template <typename T>",
            "struct ModInt {",
            "public:",
            "    constexpr ModInt() : x(0) {}",
            "    constexpr ModInt(T x_) : x(safeMod(x_, mod())) {}",
            "",
            "    constexpr static T mod() {",
            "        return static_cast<T>(mod_);",
            "    }",
            "",
            "    constexpr T val() const {",
            "        return x;",
            "    }",
            "",
            "    constexpr ModInt operator-() const {",
            "        return ModInt(x == 0 ? 0 : mod() - x);",
            "    }",
            "",
            "    constexpr ModInt pow(ll b) const { ", 
            "        ModInt res = 1;",
            "        ModInt a = *this; ",
            "        while (b > 0) {",
            "            if (b & 1) {",
            "                res *= a;",
            "            }",
            "            a *= a;",
            "            b >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    constexpr ModInt inv() const {",
            "        assert(x != 0);",
            "        return pow(mod() - 2); ",
            "    }",
            "",
            "    constexpr ModInt &operator*=(const ModInt &rhs) & {",
            "        x = (static_cast<long long>(x) * rhs.x) % mod();",
            "        return *this;",
            "    }",
            "",
            "    constexpr ModInt &operator+=(const ModInt &rhs) & {",
            "        x += rhs.x;",
            "        if (x >= mod()) {",
            "            x -= mod();",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    constexpr ModInt &operator-=(const ModInt &rhs) & {",
            "        x -= rhs.x;",
            "        if (x < 0) {",
            "            x += mod();",
            "        }",
            "        return *this;",
            "    }",
            "",
            "    constexpr ModInt &operator/=(const ModInt &rhs) & {",
            "        return *this *= rhs.inv();",
            "    }",
            "",
            "    friend constexpr ModInt operator*(ModInt lhs, const ModInt &rhs) {",
            "        lhs *= rhs;",
            "        return lhs;",
            "    }",
            "",
            "    friend constexpr ModInt operator+(ModInt lhs, const ModInt &rhs) {",
            "        lhs += rhs;",
            "        return lhs;",
            "    }",
            "",
            "    friend constexpr ModInt operator-(ModInt lhs, const ModInt &rhs) {",
            "        lhs -= rhs;",
            "        return lhs;",
            "    }",
            "",
            "    friend constexpr ModInt operator/(ModInt lhs, const ModInt &rhs) {",
            "        lhs /= rhs;",
            "        return lhs;",
            "    }",
            "",
            "    friend constexpr bool operator==(const ModInt &lhs, const ModInt &rhs) {",
            "        return lhs.val() == rhs.val();",
            "    }",
            "",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt &a) {",
            "        T i;",
            "        is >> i;",
            "        a = i;",
            "        return is;",
            "    }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt &a) {",
            "        return os << a.val();",
            "    }",
            "",
            "private:",
            "    static constexpr T mod_ = 1000000007;",
            "    T x;",
            "};",
            "",
            "using Z = ModInt<long long>;",
            "// Mod template ends here"
        ],
        "description": "Modular Arithmetic Template with ModInt Structure"
    },    
    
    // GCD & LCM
    "gcd": {
        "prefix": "gcd",
        "body": [
            "ll gcd(ll a, ll b) {",
            "\treturn b == 0 ? a : gcd(b, a % b);",
            "}"
        ],
        "description": "Calculate GCD using Euclidean Algorithm"
    },
    "lcm": {
        "prefix": "lcm",
        "body": [
            "ll lcm(ll a, ll b) {",
            "\treturn (a / gcd(a, b)) * b;",
            "}"
        ],
        "description": "Calculate LCM using GCD"
    },
    
    // Input Vector
    "input_vector": {
        "prefix": "vin",
        "body": [
            "void vin(vector<ll> &v, ll n) {",
            "\tfor (ll i = 0; i < n; i++) cin >> v[i];",
            "}"
        ],
        "description": "Input values into a vector"
    },

    // Output Vector
    "output_vector": {
        "prefix": "vout",
        "body": [
            "void vout(const vector<ll> &v) {",
            "\tfor (auto &val : v) cout << val << \" \";",
            "\tcout << endl;",
            "}"
        ],
        "description": "Output values of a vector"
    },

    // Prime Checking
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "bool isPrime(ll n) {",
            "\tif (n <= 1) return false;",
            "\tif (n <= 3) return true;",
            "\tif (n % 2 == 0 || n % 3 == 0) return false;",
            "\tfor (ll i = 5; i * i <= n; i += 6) {",
            "\t\tif (n % i == 0 || n % (i + 2) == 0) return false;",
            "\t}",
            "\treturn true;",
            "}"
        ],
        "description": "Check if a number is prime"
    },

    // Debugging
    "debug_variable": {
        "prefix": "debug",
        "body": [
            "#ifndef ONLINE_JUDGE",
            "#define debug(x) cerr << #x << \" = \" << x << endl;",
            "#else",
            "#define debug(x)",
            "#endif"
        ],
        "description": "Debugging snippet"
    },
    
    // Power Modulo
    "power_mod": {
        "prefix": "powermod",
        "body": [
            "ll powermod(ll x, ll y, ll p) {",
            "\tll res = 1;",
            "\tx = x % p;",
            "\tif (x == 0) return 0;",
            "\twhile (y > 0) {",
            "\t\tif (y & 1) res = (res * x) % p;",
            "\t\ty = y >> 1;",
            "\t\tx = (x * x) % p;",
            "\t}",
            "\treturn res;",
            "}"
        ],
        "description": "Power Modulo Function"
    },

    // Binary to Decimal
    "binary_to_decimal": {
        "prefix": "bin_to_dec",
        "body": [
            "ll binaryToDecimal(string n) {",
            "\tll dec_value = 0;",
            "\tint base = 1;",
            "\tint len = n.length();",
            "\tfor (int i = len - 1; i >= 0; i--) {",
            "\t\tif (n[i] == '1') dec_value += base;",
            "\t\tbase = base * 2;",
            "\t}",
            "\treturn dec_value;",
            "}"
        ],
        "description": "Binary to Decimal Conversion"
    },

    // Sieve of Eratosthenes
    "sieve_eratosthenes": {
        "prefix": "sieve",
        "body": [
            "vector<bool> sieve(int n) {",
            "\tvector<bool> is_prime(n + 1, true);",
            "\tis_prime[0] = is_prime[1] = false;",
            "\tfor (ll i = 2; i * i <= n; i++) {",
            "\t\tif (is_prime[i]) {",
            "\t\t\tfor (ll j = i * i; j <= n; j += i) {",
            "\t\t\t\tis_prime[j] = false;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\treturn is_prime;",
            "}"
        ],
        "description": "Generate prime numbers up to n using Sieve of Eratosthenes"
    },
    // interactive
    "interactive":{
        "prefix": "interactive",
        "body": [
            "ll query(ll l, ll r){",
            "\tcout<<\"? \"<<l<<\" \"<<r<<endl;",
            "\tll val;",
            "\tcin>>val;",
            "\treturn val;",
            "}"
        ],
    }
}
